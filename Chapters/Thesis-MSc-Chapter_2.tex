% #############################################################################
% This is Chapter 2
% !TEX root = ../main.tex
% #############################################################################
% Change the Name of the Chapter i the following line
\fancychapter{Background and Related Work}
\cleardoublepage
% The following line allows to ref this chapter
\label{chap:background}

This section goes into detail on the necessary concepts required to perfectly understand the problem, the proposed solution and the rationalization process behind it. It starts by providing an overview of cryptographic services, primitives and protocols. Then it presents several general purpose computing systems and ends by presenting other relevant components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cryptography}\label{chap:background:crypto}

There are several cryptographic services relevant to this work, namely:
\begin{itemize}
    \item Confidentiality: used to hide the content of information from unauthorized entities;
    \item Data Integrity: ability to protect from unauthorized modification of data;
    \item Authentication: used to ascertain the origin of a message;
	    %Authentication is achieved if the combination of data integrity and freshness (prevention of replay attacks: when a valid message is replayed by a malicious entity);
    
    \item Non-Repudiation: prevents an entity from denying the authorship of a document or message.
\end{itemize}

To guarantee these services, two types of key infrastructure exist: symmetric and asymmetric.
Symmetric keys are shared by two or more communicating parties. The same key is used to encrypt and decrypt data. The keys are smaller and the operations are faster than with asymmetric keys.

Asymmetric keys constitute a pair for each party, one private and one public key. The private key is personal to its owner and should never be shared. The public key may be shared widely to other parties. Asymmetric keys are bigger and the operations are slower compared to symmetric key algorithms.

There are two types of ciphers regarding the procedure: stream and block ciphers.
Stream ciphers generate an infinite stream of pseudo-random bits as the key, know as key-stream. The stream is used to encrypt, usually 1 bit of plaintext at a time. The operation to combine the key-stream and plaintext is an exclusive-or (XOR). Stream ciphers are usually faster than block ciphers, have lower memory requirements and thus are more suitable to embedded devices with limited memory. However they are prone to weaknesses if not implemented correctly, in particular, using the same \ac{IV} more than once. 

Block ciphers encrypt fixed-length groups of bits, called blocks, with a symmetric key. They have a higher memory usage, in order to keep the blocks in memory. Since the plaintext is encrypted one block at a time, if the plaintext length is not a multiple of the block size, the last block needs to be padded. Another caveat of blocks ciphers is, they are more susceptible to noise in transmissions. If a bit is flipped with a stream cipher, only the corresponding bit is affected. While with a block cipher, more than 1 bit is affected, depending on the mode.

Symmetric ciphers support both block and stream ciphers while asymmetric use block ciphers.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hash Functions}\label{chap:background:crypto:hash}

A cryptography hash function generates a fixed dimension value (digest) based on variable input texts, such as messages or files. Secure hashes provide message integrity by comparing digests, calculated before, and after, transmission to determine if the message was altered. To achieve this, hash functions must have several properties:
\begin{enumerate}
    \item They must be deterministic, meaning the same input value must always result in the same hash value;
    \item They must generate very different output values for similar inputs;
    \item They must be collision resistant, meaning it should be hard to find two input messages that generate the same hash value;
    \item The hash value should be computed relatively quickly;
    \item Given a hash value, it should be hard to find an input text that produces that hash value.
\end{enumerate}

Popular and recommended hash functions include \ac{SHA}-2 and the newer \ac{SHA}-3~\cite{dang2015secure}. Both versions have several flavours. \ac{SHA}-2 provides different functions which vary on the size of the digest. For example, the \ac{SHA}-256 function produces a 256 bit digest and \ac{SHA}-512 a 512 bit digest.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symmetric Encryption}\label{chap:background:crypto:symmetric}

Symmetric ciphers use symmetric keys and are frequently used to achieve data integrity, authentication and confidentiality.

The \ac{AES} is one of the most popular symmetric-key algorithms and its different modes of operation. It uses 128-bit blocks for block cipher modes and the keys can be 128, 192 or 256 bits. \ac{AES} has both block and stream cipher modes. Relevant modes for this work, are presented next.

\textbf{\ac{ECB}} is the simplest mode. It is a block cipher and works by encrypting each block with the symmetric key. If the same key is used, for equal plaintext blocks, the result will always be the same. For this reason, patterns are easily seen and the mode is considered insecure.

\textbf{\ac{CBC}} is another block cipher mode. It combines the first block of plaintext and an IV with the XOR operator and encrypts the result. For the subsequent blocks, the previous ciphertext is used instead of the IV. The message needs to be padded to a multiple of the block size. If this is not done correctly, it can be exploited with a padding oracle attack \cite{paddingoracle}. Implementing ciphertext stealing, resolves the issue and is recommended for the security of \ac{CBC} \cite{ciphertextstealing}.
Encryption is not parallelizable, since a ciphertext block depends on all the blocks before it. Another disadvantage of \ac{CBC} is it cannot precompute data to improve encryption performance.
To decrypt a ciphertext block, only the previous ciphertext block is needed. Therefore random read access is supported and decryption can be parallelized.
Regarding error propagation, when a bit is flipped in the ciphertext, the plaintext block will be completely corrupted and the corresponding bit of the next block will be inverted.

The \textbf{\ac{OFB}} mode repeatedly encrypts the IV for each block, xoring the result with the plaintext block.
The encryption and decryption processes are exactly the same.
The block cipher is only used in the encryption direction, which means the message does not need to be padded. It is effectively a stream cipher.
The downside of needing to encrypt the IV multiple times, is the encryption and decryption are not parallelizable and random read access is not possible. However, the multiple encryptions of the IV can be precomputed in order to increase the performance of both encryption and decryption.
Changes to a ciphertext block, only affect the corresponding bits.

\textbf{\ac{CFB}} is a combination of \ac{OFB} and \ac{CBC}. The xor operation is applied on the encrypted \ac{IV} with the plaintext block. The result is then used for the next block.
Similarly to \ac{OFB}, \ac{CFB} is effectively a stream cipher. Yet, akin to \ac{CBC}, and for the same reasons, encryption is not parallelizable, opposed to decryption which is. Random read access is possible, contrary to preprocessing which is not.
A specific condition of \ac{CFB} is it can become self-synchronous, meaning it will recover if s bits are lost. If s=1, it can recover from slips of any number of bits, if s=8 it can recover from slips of any number of bytes. However for every blockcipher call, \ac{CFB} only processes s bits, compared to 128 bits (block size), which is a major performance cost.

\textbf{\ac{CTR}} mode concatenates an IV with a counter beginning at 0. Each sequence is encrypted and applied the xor operation with the plaintext block. For each block the sequence is incremented by 1.
This mode is comparable to \ac{OFB}, as it is also a stream cipher, the encryption operation is exactly the same as the decryption and an error affects only the respective bits.
However it does not have the performance disadvantages of \ac{OFB}. Encryption and decryption are parallelizable, random read access and preprocessing are both possible.
It is worth noting that due to existing no need to implement decryption, it can save hardware costs and simplify code.

For every mode with an \ac{IV}, it needs to be sent along with the message to the receiver, or the receiver will not be able to retrieve the entire message.

\ac{CBC}, \ac{OFB} and \ac{CFB} modes are proved secure, assuming the \ac{IV} is random, and is unique, meaning it is only used once for each key and message. For \ac{CTR} mode, the IV does not need to be random, but it cannot be reused with the same key.
After the \ac{IV} is used, there is no need for the value to be kept secret. It can be sent alongside the ciphertext.

Regarding performance, the paper~\cite{aesmodes} states \ac{CBC} is slower than \ac{CTR} mode. \ac{CFB} (even with s = 128) and \ac{OFB} are slower still.
When efficiency characteristics matter, nothing comes close to \ac{CTR}: it has better performance characteristics, in multiple dimensions, than any of \ac{CBC}, \ac{CFB}, and \ac{OFB}.

All these cipher modes are malleable, meaning an attacker can modify a ciphertext C, the result of encrypting plaintext P, to create ciphertext C' which will decrypt to plaintext P' that is similar to P. Malleability is connected to message integrity. This is not considered a relevant weakness since the modes only goal is to offer confidentiality guarantees, not integrity. If one wishes integrity it should pair one of these modes with a \ac{MAC}, or use a dedicated authenticated-encryption mode like \ac{CCM} or \ac{GCM} (discussed in Section~\ref{chap:background:crypto:aead}), which guarantee both confidentiality and integrity.

\ac{XTS} is intended for encrypting data on a storage device. The mode is not approved for any other use. Instead of an IV, it uses the sector number and block index in the sector. It uses a ciphertext stealing to avoid padding in the last block. As expected, it provides no integrity. Therefore is susceptible to data tampering, any ciphertext will be decrypted, regardless of being modified or not.
% XTS can be combined with a file system with checksums (related to hash functions, also used to verify data integrity) for all data and metadata on disk, such as ZFS or Btrfs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Message Authentication Code}\label{chap:background:crypto:mac}

\ac{MAC} is a value, also called tag, used for authenticating a message.
A \ac{MAC} algorithm, receives the message and a symmetric key, to generate a tag. Unlike digital signatures, \ac{MAC} do not offer non-repudiation since it uses a symmetric key, which need to be distributed to all parties. Any of the users in possession of the key can generate a \ac{MAC} for a message, as well as verify it. On the contrary, digital signatures utilize the private key from asymmetric cryptography, which is personal.

Several techniques exist to construct a \ac{MAC}. One is \textbf{\ac{CBC-MAC}}, which utilizes the \ac{CBC} block cipher to encrypt data. A chain of blocks is generated, and the last block is the tag.
\ac{CBC-MAC} also has similar caveats to \ac{CBC}, it is only secure for fixed-length messages \cite{aesmodes} and different keys have to be used for \ac{CBC} encryption and generating the authentication tag. 
\ac{CBC-MAC} security deficiencies were resolved with \ac{OMAC}, which is secure for variable-length messages.

\textbf{\ac{HMAC}} is different from the previous techniques, by using a cryptographic hash function, such as SHA-2, and a symmetric secret key to construct a tag. \ac{HMAC} is secure, as long as the underlying hash function used is considered secure. Therefore SHA-2 is a good option.
Despite \ac{CBC}'s inefficiencies discussed in section \ref{chap:background:crypto:symmetric}, specifically, each block is serially encrypted, \ac{HMAC} is slower due to the inefficient hashing operations. However, \ac{HMAC} does not have the security problems of \ac{CBC-MAC}. \ac{HMAC} is a popular and well-designed construction, but it is not the most efficient approach~\cite{aesmodes}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Authenticated Encryption}\label{chap:background:crypto:aead}

 \ac{AEAD} schemes assure both confidentiality and authenticity using only symmetric keys. They may be more efficient than combining separate privacy and authentication techniques, such as the ones discussed in earlier sections, and are less likely to be used incorrectly. \ac{AEAD} schemes also allows associated data to be included in the message, which is authenticated but not encrypted. This feature is useful, for example, for network packets. The header is visible but is authenticated. The payload is both authenticated and encrypted. 

\textbf{\ac{CCM}} is an \ac{AEAD} mode that combines \ac{CBC-MAC} for authentication and \ac{CTR} for encryption.
\ac{CCM} uses a MAC-then-Encrypt approach. First, \ac{CBC-MAC} is computed on the message to obtain the tag. Then the message and the tag are encrypted with \ac{CTR} mode.
Due to performing two encryption operations, \ac{CBC-MAC} and then \ac{CTR}, it is a less efficient mode compared to others such as \ac{GCM}, which only performs one encryption operation.
It is not an online mode, meaning it needs to know the message and \ac{AD} length beforehand. Therefore, \ac{AD} cannot be preprocessed. It is only considered secure for fixed-length messages.
Despite being a slower mode, it is secure and achieves its goals, so it is widely supported, included in \ac{IPsec}, \ac{TLS} and Bluetooth low energy.

\ac{EAX} mode aims to improve on \ac{CCM} by replacing \ac{CBC-MAC} with \ac{OMAC}. Similarly to \ac{CCM}, it first generates the authentication tag with \ac{OMAC}, then encrypts with \ac{CTR}.
By using \ac{OMAC} instead of \ac{CBC-MAC}, it supports variable-length messages and is online.

\textbf{\ac{GCM}} utilizes an encrypt-then-MAC approach. It first encrypts with \ac{CTR} mode, then uses Galois mode of authentication to generate the tag. The Galois field multiplication supports parallel computation, making this mode faster than \ac{CCM}.
Evidently, like in normal \ac{CTR} mode, it needs a different \ac{IV} for each encrypted message.
Beyond being parallelizable, it has the advantages \ac{EAX} has over \ac{CCM}. It is online and the \ac{AD} can be preproccesed.
For security reasons, authentication tags should be at least 96 bits, even though the mode allows smaller tags. One limitation of \ac{GCM} is, it can encrypt a maximum of 64GiB of plaintext. Security analysis of several modes, decisively states that \ac{GCM} in hardware is unsurpassed by any authenticated-encryption scheme~\cite{aesmodes}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Asymmetric Encryption}\label{chap:background:crypto:assymetric}

Asymmetric cryptography utilizes a pair of public and private keys. It is commonly used to provide confidentiality, data integrity, authentication and non-repudiation.
The private keys must always remain secure with the owner. Public keys may be distributed as it does not compromise security. Encrypting a message with the public key, provides confidentiality, since only the owner who possesses the private key, can decipher the message. On the other hand, private key encryption provides authentication on account of only the owner is in possession of the private key. These two different concepts can be combined to provide confidentiality, authentication and non-repudiation, through digital signatures, to a message.

Compared to symmetric keys, asymmetric keys are less risky to distribute, as the public key can be viewed by anyone. However, there is the problem of validating public keys, which consists of guaranteeing a public key is owned by the correct identity.

Once two parties have traded public keys, asymmetric and symmetric keys can be combined in a hybrid encryption scheme. The scheme takes advantage of the faster symmetric encryption to cipher the data, and the asymmetric encryption to encrypt the symmetric key, and provide authentication. Alternatively, it can be used to share symmetric keys for usage with an authenticated-encryption scheme.

% ECC, RSA
There are two popular algorithms for public-key encryption, \ac{RSA} and \ac{ECC}~\cite{mahto2016security}.
\ac{RSA} has been used for decades, it is well established and widely used. It is based on the difficulty of factoring the product of two large prime numbers.

\ac{ECC} is a more recent algorithm, based on the Elliptic Curve Discrete Logarithm Problem. For the same level of security, \ac{ECC} keys are smaller. Gupta \& Silakari, 2011~\cite{eccoverrsa}, give as an example a 160-bit \ac{ECC} key has similar security to a 1024-bit \ac{RSA} key. They also state that smaller key sizes may result in faster execution timings for the schemes, which is beneficial to systems where real time performance is a critical factor.
With the threat of quantum computers, both \ac{ECC} and \ac{RSA} could become obsolete in the future, as it is vulnerable to brute force attacks from such devices.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Digital Signatures}\label{chap:background:crypto:signatures}

Signatures is a standard scheme for authenticating documents or digital messages and ensuring the signer cannot repudiate the signature. The digital signature is generated by a combination of asymmetric keys and hash functions.
The digital signature is generated by first computing a hash of the message, then signing the hash with the author's private key. The message is not directly signed since public-key encryption is slow and messages are most likely bigger than the hash of the message, which has a fixed size. Third parties can validate the signature with the author's public key. Only the author, in possession of their private key, could have generated the signature.
They are a digital version of handwritten signatures~\cite{digitalsignatures}, commonly used anywhere forgery detection is essential, for instance in financial transactions or software distribution.

Qualified signatures are a special type of signatures where the private keys are generated and stored inside a device, such as a Smart Card, and never leave it. For the owner to sign a document, the Smart Card is needed (something owned) and a \ac{PIN} (something known). This strong signature legally represents a person or a group. This type of signatures are used in the Portuguese Citizen Card.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Public Key Infrastructure}\label{chap:background:PKI}

Asymmetric cryptographic needs a secure mechanism to validate public keys, achieved by guaranteeing a public key is owned by a certain identity.
A \ac{PKI} is a central database of public-key certificates. It is responsible for managing, distributing, storing and revoking digital certificates. Digital certificates map public keys to identities and are used to verify that a specific public key belongs to a certain identity.
A \ac{PKI} has several components e.g.\ a registration authority, a certification authority and a central database of stored keys.
A user can also submit other entities' public keys. Other entities that trust the user responsible for the submission, can use the public keys to authenticate messages.
There are alternative approaches to \ac{PKI}, such as a web of trust. This mechanism self-signs certificates and third parties attest these certificates. This approach is implemented in \ac{PGP}~\cite{modelingPKI}.

%TLS
\subsection{Transport Layer Security}\label{chap:background:TLS}

\textbf{\ac{TLS}} is a cryptographic protocol that aims to provide confidentiality and data integrity, during transmission, over TCP/IP \cite{rescorla2018transport}. It uses symmetric cryptography to encrypt data. A new symmetric key is generated for each connection.
\ac{TLS} supports asymmetric cryptography which authenticates the identity of the communicating parties.
\ac{TLS} is widely used in web browsing, e-mail and instant messaging.
The protocol can provide perfect forward secrecy, unlike \ac{PGP}, assuring any past connections are secure, if in the future encryptions keys are disclosed.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Secure Cryptoprocessors}  \label{processors}
\section{Other Important Concepts}\label{chap:background:other}

There are some important concepts to consider involving cryptography and secure cryptoprocessors.

\subsection{Random Number Generators}
A \ac{TRNG} can generate a sequence of numbers that cannot be predicted. Generating random numbers is a common and critical requirement for almost all cryptographic algorithms. Pseudo-random number generators are frequent in software approaches and are not truly random. They depend on an algorithm and initial conditions (seed) to generate random numbers. If the seed is known, the numbers are predictable.
\ac{TRNG} are hardware devices that generate numbers from microscopic physical conditions. These conditions are completely unpredictable. For this reason, \ac{TRNG}s are perfect for use in cryptography and secure cryptoprocessors.

\subsection{Public-Key Cryptography Standards \#11}
\ac{PKCS} \#11 are a group of cryptographic standards, published by RSA Laboratories, which describe guidelines to manipulate common cryptographic objects.
The standards defines an \ac{API} designed to interface between applications and cryptographic devices such as smart cards and hardware security modules~\cite{pkcs11analysis}. 
Applications can use, create and modify objects, without exposing them to the application's memory.
The standard has been widely used, promoting interoperability between devices. By using the same standard, it allows devices to take advantage of another device's \ac{API}.
It allows applications to access cryptographic devices through slots. The slots represent a socket or device reader. A session can be established through the slot so the application can authenticate itself to a token with a default \ac{PIN}. The token holds private and public objects which can be keys and certificates. Only public objects are available to an unauthenticated session. The normal user has access to both private and public objects but cannot change the authentication \ac{PIN}s. The privileged user can change both his and the normal user's \ac{PIN}.
% An attack scenario is possible if the host machine is compromised, an attacker can intercept the \ac{PIN}, which he can use to access the cryptographic device.
\section{Secure Cryptoprocessors}\label{chap:background:cryptoprocessors}

In this section we discuss some computing systems that may be pertinent to this work. 

Secure cryptoprocessors are dedicated physical computational devices for performing cryptographic operations. Some secure cryptoprocessors namely, Smart Cards, Trusted Platform Modules and Hardware Security Modules will be discussed next.

% HSM
\subsection{Hardware Security Modules}\label{chap:background:computing:hsm}

A \ac{HSM} is a high grade computational device responsible for storage, management and generation of cryptographic keys, as well as performing cryptographic operations. Keys never leave the device and all operations are performed inside the \ac{HSM}. These devices have physical security mechanisms to achieve tamper-resistance, support several cryptographic operations, random number generators and have fail-safe mechanisms in place, in case of an attack, e.g., deletion of keys. Some devices have accelerated \ac{CPU} and optimizations to improve operations' performance.
These modules are usually costlier than other computational systems i.e. \ac{TPM}s, but are more advanced in processing power and available operations.

% smartcards
\subsection*{Smart Cards}\label{chap:background:computing:smartcards}
Smart Cards are a type of \ac{HSM}, credit card-sized with an embedded microchip and provide secure, tamper-resistant storage. These devices have a low price for manufacturing, which allows for bulk production of the device and easy replacement if needed. However, the disadvantage is it makes it easy for attackers to acquire many devices to try to tamper with. They have a low processing power, and small memory which only allows to store a small amount of data. To be authenticated, the cards need readers that are either contact or contactless (RFID technology). These characteristics make them extremely popular, used in many industries, such as, retail, healthcare, communication and government.

% descrever smartfusion, caracteristicas, o que suporta, etc.
\subsection{Field-Programmable Gate Array System-on-Chip}\label{chap:background:computing:smartfusion}
A \ac{FPGA} is an integrated circuit designed to be programmed and configured after manufacturing. \ac{FPGA}s are often used to prototype and for high specialized systems produced at low scale. One of the major advantages is their agility and flexibility to be customized for special use cases~\cite{cyberphysicalsystems}. However, the reconfigurability may introduce certain weaknesses to the system. \ac{FPGA}s are generic and its bitstream is vulnerable to cloning if no additional protection is applied. Cloning is simple and is considered the worst security vulnerability of volatile \ac{FPGA}s~\cite{fpgasurvey}. The configuration data of these devices is stored in non-volatile memory and may be directly copied if no authentication mechanism is implemented~\cite{drimer2007authentication}.

An example of such device is the SmartFusion2 \ac{SoC} from Microsemi that delivers more resources in low-density devices with the lowest power, proven security, and exceptional reliability~\cite{smartfusion2soc}. Smartfusion2 integrates a non-volatile \ac{FPGA} with a \ac{SoC} and an internal secure eNVM for storing Phase 0 boot code. Since they are non-volatile, the bitstream is at a lower risk of being probed during boot~\cite{parrinha2017flexible}. The eSRAM flash memory is protected against single event upsets. Smartfusion2 has an embedded ARM Cortex-M3 processor and a \ac{TRNG}, which provides a quality source of entropy, a critical part of most cryptographic algorithms. It supports multiple cryptographic functions: \ac{AES}-256, \ac{SHA}-256 and \ac{ECC}, among others.

\subsubsection*{Secure boot}
Not validating code before its execution leads to potentially executing untrusted code. This causes problems such as hackers inserting malware to hijack systems, download intellectual property, spy on users or perform any number of attacks.
Most embedded processors do not validate code before it is executed. The SmartFusion2 \ac{SoC} solves this problem by using a non-volatile memory (eNVM) to store boot code which can be write protected. Another reason is it authenticates each stage of the boot process to create a chain-of-trust.
Other systems also implement solutions to secure boot code. Infineon secures the boot process for ARM platforms by incorporating a \ac{TPM}, compliant with version 1.2, into the processor. The \ac{TPM} operates as a root of trust to certify the platform's integrity and correct system state. This prevents tampered kernels and fault attacks.
Texas Instruments Sitara processors allows the customer to specify a public key as a root of trust to be fused into the device. This key is used to authenticate other keys that can be used to authenticate software components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
