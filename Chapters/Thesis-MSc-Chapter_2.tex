% #############################################################################
% This is Chapter 2
% !TEX root = ../main.tex
% #############################################################################
% Change the Name of the Chapter i the following line
\fancychapter{Background and Related Work}
\cleardoublepage
% The following line allows to ref this chapter
\label{chap:background}

This section goes into detail on the necessary concepts required to perfectly understand the problem, the proposed solution and the rationalization process behind it. It starts by providing an overview of cryptographic services, primitives and protocols. Then it presents several general purpose computing systems and ends by presenting other relevant components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cryptography}\label{chap:background:crypto}

There are several cryptographic services relevant to this work, namely: Confidentiality: used to hide the content of information from unauthorized entities; Data Integrity: ability to protect from unauthorized modification of data; Authentication: used to ascertain the origin of a message; Non-Repudiation: prevents an entity from denying the authorship of a document or message.
% \begin{itemize}
%     \item Confidentiality: used to hide the content of information from unauthorized entities;
%     \item Data Integrity: ability to protect from unauthorized modification of data;
%     \item Authentication: used to ascertain the origin of a message;
%             %Authentication is achieved if the combination of data integrity and freshness (prevention of replay attacks: when a valid message is replayed by a malicious entity);
%     \item Non-Repudiation: prevents an entity from denying the authorship of a document or message.
% \end{itemize}

To guarantee these services, two types of key infrastructure exist: symmetric and asymmetric.
Symmetric keys are shared by two or more communicating parties. The same key is used to encrypt and decrypt data. The keys are smaller and the operations are faster than with asymmetric keys.

Asymmetric keys constitute a pair for each party, one private and one public key. The private key is personal to its owner and should never be shared. The public key may be shared widely to other parties. Asymmetric keys are bigger and the operations are slower compared to symmetric key algorithms.

There are two types of ciphers regarding the procedure: stream and block ciphers.
Stream ciphers generate an infinite stream of pseudo-random bits as the key, know as key-stream. The stream is used to encrypt, usually 1 bit of plaintext at a time. The operation to combine the key-stream and plaintext is an exclusive-or (XOR). Stream ciphers are usually faster than block ciphers, have lower memory requirements and thus are more suitable to embedded devices with limited memory. However they are prone to weaknesses if not implemented correctly, in particular, using the same \ac{IV} more than once. 

Block ciphers encrypt fixed-length groups of bits, called blocks, with a symmetric key. They have a higher memory usage, in order to keep the blocks in memory. Since the plaintext is encrypted one block at a time, if the plaintext length is not a multiple of the block size, the last block needs to be padded. Another caveat of blocks ciphers is, they are more susceptible to noise in transmissions. If a bit is flipped with a stream cipher, only the corresponding bit is affected. While with a block cipher, more than 1 bit is affected, depending on the mode.

Symmetric ciphers support both block and stream ciphers while asymmetric use block ciphers.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hash Functions}\label{chap:background:crypto:hash}

A cryptography hash function generates a fixed dimension value (digest) based on variable input texts, such as messages or files. Secure hashes provide message integrity by comparing digests, calculated before, and after, transmission to determine if the message was altered.
To achieve this, hash functions must have several properties, more notably: the same input value always results in the same hash, very different outputs must be generated for very similar inputs, it should be hard to find two messages which generate the same hash and it should be hard to find n input that produces a given hash.
% \begin{enumerate}
%     \item They must be deterministic, meaning the same input value must always result in the same hash value;
%     \item They must generate very different output values for similar inputs;
%     \item They must be collision resistant, meaning it should be hard to find two input messages that generate the same hash value;
%     \item The hash value should be computed relatively quickly;
%     \item Given a hash value, it should be hard to find an input text that produces that hash value.
% \end{enumerate}

Popular and recommended hash functions include \ac{SHA}-2 and the newer \ac{SHA}-3~\cite{dang2015secure}. Both versions have several flavours. \ac{SHA}-2 provides different functions which vary on the size of the digest. For example, the \ac{SHA}-256 function produces a 256 bit digest and \ac{SHA}-512 a 512 bit digest.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symmetric Encryption}\label{chap:background:crypto:symmetric}

Symmetric ciphers use symmetric keys and are frequently used to achieve data integrity, authentication and confidentiality.

The \ac{AES} is one of the most popular symmetric-key algorithms and its different modes of operation. It uses 128-bit blocks for block cipher modes and the keys can be 128, 192 or 256 bits. \ac{AES} has both block and stream cipher modes. Relevant modes for this work, are presented next.

\textbf{\ac{ECB}} is the simplest mode. It is a block cipher and works by encrypting each block with the symmetric key. If the same key is used, for equal plaintext blocks, the result will always be the same. For this reason, patterns are easily seen and the mode is considered insecure.

\textbf{\ac{CBC}} is another block cipher mode. It combines the first block of plaintext and an IV with the XOR operator and encrypts the result. For the subsequent blocks, the previous ciphertext is used instead of the IV. The message needs to be padded to a multiple of the block size. If this is not done correctly, it can be exploited with a padding oracle attack \cite{paddingoracle}. Implementing ciphertext stealing, resolves the issue and is recommended for the security of \ac{CBC} \cite{ciphertextstealing}.
Encryption is not parallelizable, since a ciphertext block depends on all the blocks before it. Another disadvantage of \ac{CBC} is it cannot precompute data to improve encryption performance.
To decrypt a ciphertext block, only the previous ciphertext block is needed. Therefore random read access is supported and decryption can be parallelized.
Regarding error propagation, when a bit is flipped in the ciphertext, the plaintext block will be completely corrupted and the corresponding bit of the next block will be inverted.

The \textbf{\ac{OFB}} mode repeatedly encrypts the IV for each block, xoring the result with the plaintext block.
The encryption and decryption processes are exactly the same.
The block cipher is only used in the encryption direction, which means the message does not need to be padded. It is effectively a stream cipher.
The downside of needing to encrypt the IV multiple times, is the encryption and decryption are not parallelizable and random read access is not possible. However, the multiple encryptions of the IV can be precomputed in order to increase the performance of both encryption and decryption.
Changes to a ciphertext block, only affect the corresponding bits.

% \textbf{\ac{CFB}} is a combination of \ac{OFB} and \ac{CBC}. The xor operation is applied on the encrypted \ac{IV} with the plaintext block. The result is then used for the next block.
% Similarly to \ac{OFB}, \ac{CFB} is effectively a stream cipher. Yet, akin to \ac{CBC}, and for the same reasons, encryption is not parallelizable, opposed to decryption which is. Random read access is possible, contrary to preprocessing which is not.
% A specific condition of \ac{CFB} is it can become self-synchronous, meaning it will recover if s bits are lost. If s=1, it can recover from slips of any number of bits, if s=8 it can recover from slips of any number of bytes. However for every blockcipher call, \ac{CFB} only processes s bits, compared to 128 bits (block size), which is a major performance cost.
%
\textbf{\ac{CTR}} mode concatenates an IV with a counter beginning at 0. Each sequence is encrypted and applied the xor operation with the plaintext block. For each block the sequence is incremented by 1.
This mode is comparable to \ac{OFB}, as it is also a stream cipher, the encryption operation is exactly the same as the decryption and an error affects only the respective bits.
However it does not have the performance disadvantages of \ac{OFB}. Encryption and decryption are parallelizable, random read access and preprocessing are both possible.
It is worth noting that due to existing no need to implement decryption, it can save hardware costs and simplify code.

For every mode with an \ac{IV}, it needs to be sent along with the message to the receiver, or the receiver will not be able to retrieve the entire message.

% \ac{CBC}, \ac{OFB} and \ac{CFB} modes are proved secure, assuming the \ac{IV} is random, and is unique, meaning it is only used once for each key and message. For \ac{CTR} mode, the IV does not need to be random, but it cannot be reused with the same key.
\ac{CBC} and \ac{OFB} modes are proved secure, assuming the \ac{IV} is random, and is unique, meaning it is only used once for each key and message. For \ac{CTR} mode, the IV does not need to be random, but it cannot be reused with the same key.
After the \ac{IV} is used, there is no need for the value to be kept secret. It can be sent alongside the ciphertext.

% Regarding performance, the paper~\cite{aesmodes} states \ac{CBC} is slower than \ac{CTR} mode. \ac{CFB} (even with s = 128) and \ac{OFB} are slower still.
Regarding performance, the paper~\cite{aesmodes} states \ac{CBC} is slower than \ac{CTR} mode. \ac{OFB} is even slower.
When efficiency characteristics matter, nothing comes close to \ac{CTR}: it has better performance characteristics, in multiple dimensions, than any of \ac{CBC}, and \ac{OFB}.

All these cipher modes are malleable, meaning an attacker can modify a ciphertext C, the result of encrypting plaintext P, to create ciphertext C' which will decrypt to plaintext P' that is similar to P. Malleability is connected to message integrity. This is not considered a relevant weakness since the modes only goal is to offer confidentiality guarantees, not integrity. If one wishes integrity it should pair one of these modes with a \ac{MAC}, or use a dedicated authenticated-encryption mode like \ac{CCM} or \ac{GCM} (discussed in Section~\ref{chap:background:crypto:aead}), which guarantee both confidentiality and integrity.

% \ac{XTS} is intended for encrypting data on a storage device. The mode is not approved for any other use. Instead of an IV, it uses the sector number and block index in the sector. It uses a ciphertext stealing to avoid padding in the last block. As expected, it provides no integrity. Therefore is susceptible to data tampering, any ciphertext will be decrypted, regardless of being modified or not.
% XTS can be combined with a file system with checksums (related to hash functions, also used to verify data integrity) for all data and metadata on disk, such as ZFS or Btrfs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Message Authentication Code}\label{chap:background:crypto:mac}

\ac{MAC} is a value, also called tag, used for authenticating a message.
A \ac{MAC} algorithm, receives the message and a symmetric key, to generate a tag. Unlike digital signatures, \ac{MAC} do not offer non-repudiation since it uses a symmetric key, which need to be distributed to all parties. Any of the users in possession of the key can generate a \ac{MAC} for a message, as well as verify it. On the contrary, digital signatures utilize the private key from asymmetric cryptography, which is personal.

Several techniques exist to construct a \ac{MAC}. One is \textbf{\ac{CBC-MAC}}, which utilizes the \ac{CBC} block cipher to encrypt data. A chain of blocks is generated, and the last block is the tag.
\ac{CBC-MAC} also has similar caveats to \ac{CBC}, it is only secure for fixed-length messages \cite{aesmodes} and different keys have to be used for \ac{CBC} encryption and generating the authentication tag. 
\ac{CBC-MAC} security deficiencies were resolved with \ac{OMAC}, which is secure for variable-length messages.

\textbf{\ac{HMAC}} is different from the previous techniques, by using a cryptographic hash function, such as SHA-2, and a symmetric secret key to construct a tag. \ac{HMAC} is secure, as long as the underlying hash function used is considered secure. Therefore SHA-2 is a good option.
Despite \ac{CBC}'s inefficiencies discussed in section \ref{chap:background:crypto:symmetric}, specifically, each block is serially encrypted, \ac{HMAC} is slower due to the inefficient hashing operations. However, \ac{HMAC} does not have the security problems of \ac{CBC-MAC}. \ac{HMAC} is a popular and well-designed construction, but it is not the most efficient approach~\cite{aesmodes}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Authenticated Encryption}\label{chap:background:crypto:aead}

 \ac{AEAD} schemes assure both confidentiality and authenticity using only symmetric keys. They may be more efficient than combining separate privacy and authentication techniques, such as the ones discussed in earlier sections, and are less likely to be used incorrectly. \ac{AEAD} schemes also allows associated data to be included in the message, which is authenticated but not encrypted. This feature is useful, for example, for network packets. The header is visible but is authenticated. The payload is both authenticated and encrypted. 

\textbf{\ac{CCM}} is an \ac{AEAD} mode that combines \ac{CBC-MAC} for authentication and \ac{CTR} for encryption.
\ac{CCM} uses a MAC-then-Encrypt approach. First, \ac{CBC-MAC} is computed on the message to obtain the tag. Then the message and the tag are encrypted with \ac{CTR} mode.
Due to performing two encryption operations, \ac{CBC-MAC} and then \ac{CTR}, it is a less efficient mode compared to others such as \ac{GCM}, which only performs one encryption operation.
It is not an online mode, meaning it needs to know the message and \ac{AD} length beforehand. Therefore, \ac{AD} cannot be preprocessed. It is only considered secure for fixed-length messages.
Despite being a slower mode, it is secure and achieves its goals, so it is widely supported, included in \ac{IPsec}, \ac{TLS} and Bluetooth low energy.

% \ac{EAX} mode aims to improve on \ac{CCM} by replacing \ac{CBC-MAC} with \ac{OMAC}. Similarly to \ac{CCM}, it first generates the authentication tag with \ac{OMAC}, then encrypts with \ac{CTR}.
% By using \ac{OMAC} instead of \ac{CBC-MAC}, it supports variable-length messages and is online.

\textbf{\ac{GCM}} utilizes an encrypt-then-MAC approach. It first encrypts with \ac{CTR} mode, then uses Galois mode of authentication to generate the tag. The Galois field multiplication supports parallel computation, making this mode faster than \ac{CCM}.
Evidently, like in normal \ac{CTR} mode, it needs a different \ac{IV} for each encrypted message.
% Beyond being parallelizable, it has the advantages \ac{EAX} has over \ac{CCM}. It is online and the \ac{AD} can be preprocessed.
Beyond being parallelizable, it is online and the \ac{AD} can be preprocessed.
For security reasons, authentication tags should be at least 96 bits, even though the mode allows smaller tags. One limitation of \ac{GCM} is, it can encrypt a maximum of 64GiB of plaintext. Security analysis of several modes, decisively states that \ac{GCM} in hardware is unsurpassed by any authenticated-encryption scheme~\cite{aesmodes}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Asymmetric Encryption}\label{chap:background:crypto:assymetric}

Asymmetric cryptography utilizes a pair of public and private keys. It is commonly used to provide confidentiality, data integrity, authentication and non-repudiation.
The private keys must always remain secure with the owner. Public keys may be distributed as it does not compromise security. Encrypting a message with the public key, provides confidentiality, since only the owner who possesses the private key, can decipher the message. On the other hand, private key encryption provides authentication on account of only the owner is in possession of the private key. These two different concepts can be combined to provide confidentiality, authentication and non-repudiation, through digital signatures, to a message.

Compared to symmetric keys, asymmetric keys are less risky to distribute, as the public key can be viewed by anyone. However, there is the problem of validating public keys, which consists of guaranteeing a public key is owned by the correct identity.

Once two parties have traded public keys, asymmetric and symmetric keys can be combined in a hybrid encryption scheme. The scheme takes advantage of the faster symmetric encryption to cipher the data, and the asymmetric encryption to encrypt the symmetric key, and provide authentication. Alternatively, it can be used to share symmetric keys for usage with an authenticated-encryption scheme.

% ECC, RSA
There are two popular algorithms for public-key encryption, \ac{RSA} and \ac{ECC}~\cite{mahto2016security}.
\ac{RSA} has been used for decades, it is well established and widely used. It is based on the difficulty of factoring the product of two large prime numbers.

% useful for small wireless devices with processing power, storage space, or power consumption restrictions.

\ac{ECC} is a more recent algorithm, based on the Elliptic Curve Discrete Logarithm Problem. The main advantage of \ac{ECC} is it offers the same level of security, with a smaller key size. Gupta \& Silakari, 2011~\cite{eccoverrsa}, give as an example a 160-bit \ac{ECC} key has similar security to a 1024-bit \ac{RSA} key.
\ac{ECC} operations are also faster, this makes elliptic curve based schemes more suited for less powerfull and memory constrained devices \cite{selvakumaraswamy2016efficient}.
%They also state that smaller key sizes may result in faster execution timings for the schemes, which is beneficial to systems where real time performance is a critical factor.
With the threat of quantum computers, both \ac{ECC} and \ac{RSA} could become obsolete in the future, as it is vulnerable to brute force attacks from such devices.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Elliptic-curve Diffie-Hellman}\label{chap:background:crypto:ecdh}

The \ac{DH} key exchange algorithm allows two parties to agree on a shared secret, which can be used to derive a key to secure communications. Both parties compute the secret from from publicly exchanged integers, and private integers. Attackers listening on the exchanged public integers cannot compute the same secret, since both parties private integers are never shared.

\ac{ECDH} key exchange is similar, it computes the shared secret from \ac{ECC} private and public keys instead of integers. Incorporating \ac{ECC} keys provides the same level of security compared with integers, but with a smaller bit size ~\cite{fiskiran2002workload}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Digital Signatures}\label{chap:background:crypto:signatures}

Signatures is a standard scheme for authenticating documents or digital messages and ensuring the signer cannot repudiate the signature. The digital signature is generated by a combination of asymmetric keys and hash functions.
The digital signature is generated by first computing a hash of the message, then signing the hash with the author's private key. The message is not directly signed since public-key encryption is slow and messages are most likely bigger than the hash of the message, which has a fixed size. Third parties can validate the signature with the author's public key. Only the author, in possession of their private key, could have generated the signature.
They are a digital version of handwritten signatures~\cite{digitalsignatures}, commonly used anywhere forgery detection is essential, for instance in financial transactions or software distribution.

Qualified signatures are a special type of signatures where the private keys are generated and stored inside a device, such as a Smart Card, and never leave it. For the owner to sign a document, the Smart Card is needed (something owned) and a \ac{PIN} (something known). This strong signature legally represents a person or a group. This type of signatures are used in the Portuguese Citizen Card.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Public Key Infrastructure}\label{chap:background:PKI}

Asymmetric cryptographic needs a secure mechanism to validate public keys, achieved by guaranteeing a public key is owned by a certain identity.
A \ac{PKI} is a central database of public-key certificates. It is responsible for managing, distributing, storing and revoking digital certificates. Digital certificates map public keys to identities and are used to verify that a specific public key belongs to a certain identity.
A \ac{PKI} has several components e.g.\ a registration authority, a certification authority and a central database of stored keys.
A user can also submit other entities' public keys. Other entities that trust the user responsible for the submission, can use the public keys to authenticate messages.
There are alternative approaches to \ac{PKI}, such as a web of trust. This mechanism self-signs certificates and third parties attest these certificates. This approach is implemented in \ac{PGP}~\cite{modelingPKI}.

%TLS
\subsection{Transport Layer Security}\label{chap:background:TLS}

\textbf{\ac{TLS}} is a cryptographic protocol that aims to provide confidentiality and data integrity, during transmission, over TCP/IP \cite{rescorla2018transport}. It uses symmetric cryptography to encrypt data. A new symmetric key is generated for each connection.
\ac{TLS} supports asymmetric cryptography which authenticates the identity of the communicating parties.
\ac{TLS} is widely used in web browsing, e-mail and instant messaging.
The protocol can provide perfect forward secrecy, unlike \ac{PGP}, assuring any past connections are secure, if in the future encryptions keys are disclosed.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Secure Cryptoprocessors}  \label{processors}
\section{Other Important Concepts}\label{chap:background:other}

There are some important concepts to consider involving cryptography and secure cryptoprocessors.

\subsection{Random Number Generators}
A \ac{TRNG} can generate a sequence of numbers that cannot be predicted. Generating random numbers is a common and critical requirement for almost all cryptographic algorithms. Pseudo-random number generators are frequent in software approaches and are not truly random. They depend on an algorithm and initial conditions (seed) to generate random numbers. If the seed is known, the numbers are predictable.
\ac{TRNG} are hardware devices that generate numbers from microscopic physical conditions. These conditions are completely unpredictable. For this reason, \ac{TRNG}s are perfect for use in cryptography and secure cryptoprocessors.

\subsection{Public-Key Cryptography Standards \#11}
\ac{PKCS} \#11 are a group of cryptographic standards, published by RSA Laboratories, which describe guidelines to manipulate common cryptographic objects.
The standards defines an \ac{API} designed to interface between applications and cryptographic devices such as smart cards and hardware security modules~\cite{pkcs11analysis}. 
Applications can use, create and modify objects, without exposing them to the application's memory.
The standard has been widely used, promoting interoperability between devices. By using the same standard, it allows devices to take advantage of another device's \ac{API}.
It allows applications to access cryptographic devices through slots. The slots represent a socket or device reader. A session can be established through the slot so the application can authenticate itself to a token with a default \ac{PIN}. The token holds private and public objects which can be keys and certificates among others, and can be accessed by user's.
% Only public objects are available to an unauthenticated session. The normal user has access to both private and public objects but cannot change the authentication \ac{PIN}s. The privileged user can change both his and the normal user's \ac{PIN}.
% An attack scenario is possible if the host machine is compromised, an attacker can intercept the \ac{PIN}, which he can use to access the cryptographic device.
\section{Secure Cryptoprocessors}\label{chap:background:cryptoprocessors}

In this section we discuss some computing systems that may be pertinent to this work. 

Secure cryptoprocessors are dedicated physical computational devices for performing cryptographic operations. Some secure cryptoprocessors namely, Smart Cards, Trusted Platform Modules and Hardware Security Modules will be discussed next.

% HSM
\subsection{Hardware Security Modules}\label{chap:background:computing:hsm}

A \ac{HSM} is a high grade computational device responsible for storage, management and generation of cryptographic keys, as well as performing cryptographic operations. Keys never leave the device and all operations are performed inside the \ac{HSM}. These devices have physical security mechanisms to achieve tamper-resistance, support several cryptographic operations, random number generators and have fail-safe mechanisms in place, in case of an attack, e.g., deletion of keys. Some devices have accelerated \ac{CPU} and optimizations to improve operations' performance.
These modules are usually costlier than other computational systems i.e. \ac{TPM}s, but are more advanced in processing power and available operations.

% smartcards
\subsection*{Smart Cards}\label{chap:background:computing:smartcards}
Smart Cards are a type of \ac{HSM}, credit card-sized with an embedded microchip and provide secure, tamper-resistant storage. These devices have a low price for manufacturing, which allows for bulk production of the device and easy replacement if needed. However, the disadvantage is it makes it easy for attackers to acquire many devices to try to tamper with. They have a low processing power, and small memory which only allows to store a small amount of data. To be authenticated, the cards need readers that are either contact or contactless (RFID technology). These characteristics make them extremely popular, used in many industries, such as, retail, healthcare, communication and government.

% descrever smartfusion, caracteristicas, o que suporta, etc.
% \subsection{Field-Programmable Gate Array System-on-Chip}\label{chap:background:computing:smartfusion}
% A \ac{FPGA} is an integrated circuit designed to be programmed and configured after manufacturing. \ac{FPGA}s are often used to prototype and for high specialized systems produced at low scale. One of the major advantages is their agility and flexibility to be customized for special use cases~\cite{cyberphysicalsystems}. However, the reconfigurability may introduce certain weaknesses to the system. \ac{FPGA}s are generic and its bitstream is vulnerable to cloning if no additional protection is applied. Cloning is simple and is considered the worst security vulnerability of volatile \ac{FPGA}s~\cite{fpgasurvey}. The configuration data of these devices is stored in non-volatile memory and may be directly copied if no authentication mechanism is implemented~\cite{drimer2007authentication}.

\subsection{Smartfusion2 SoC}\label{chap:background:computing:smartfusion}
An example of such device is the SmartFusion2 \ac{SoC} from Microsemi that delivers more resources in low-density devices with the lowest power, proven security, and exceptional reliability~\cite{smartfusion2soc}. Smartfusion2 integrates a non-volatile \ac{FPGA} with a \ac{SoC} and an internal \ac{NVM} of 512 KB for storing Phase 0 boot code.
Since they are non-volatile, the bitstream is at a lower risk of being probed during boot~\cite{parrinha2017flexible}. It has a \ac{SRAM} with 64 KB protected against \ac{SEU} and an additional 80 KB unprotected. Smartfusion2 has an embedded ARM Cortex-M3 processor and a \ac{TRNG}, which provides a quality source of entropy, a critical part of most cryptographic algorithms. It supports multiple cryptographic functions: \ac{AES}-256, \ac{SHA}-256 and \ac{ECC}, among others.

% -----
The \ac{AES} system service supports encryption and decryption with ECB, CBC, OFB and CTR modes. It offers two services, for 128 bit and 256 bit keys.
It provides a \ac{SHA}-256 hashing service, and a \ac{HMAC} service using the same \ac{SHA}-256 function.
The KeyTree service provides access to a SHA-256 based key-tree cryptography algorithm. Notably it can be used to generate a message authentication code from a hash input and key, as a key derivation function from a root key and a salt or in challenge-response protocols.
The \ac{NRBG} service provides a raw entropy source based upon a noisy ring oscillator, measured against a system clock. It can be generate true random numbers from the unpredictable physical conditions of the board.
The device includes several relevant \ac{ECC} accelerators. It supports the \ac{NIST} defined P-384 elliptic curve.
The device can generate new 48 byte private \ac{ECC} keys. The corresponding public key can be calculated with scalar point multiplication service, by multiplying the scalar (private key) with a point (base point). This service also allows the generation of secrets with \ac{ECDH} by multiplying the device's private key, with another user's public key.
The device also includes a point addition service, which allows the implementation of an elliptic curve digital signature algorithm such as ECDSA.

% -------
The SRAM-PUF service allows the user to store extrinsic keys (value supplied by the user) and intrinsic keys (randomly generated in the device).
It holds up to 56 key slots with a maximum of 4096 bits each.
It uses the random start-up behaviour of a 2KB \ac{SRAM} block to determine a static secret unique to each device. There is enough repeatability in the SRAM turn-on behaviour to reconstruct the same secret each time. This secret is used to derive or protect cryptographic keys with 256 bit security strength \cite{smartfusionSecurityPractices}.
When power is removed, the secret disappears. There is not technology to detect the start-up behaviour of an SRAM. It is determined by atomic-scale manufacturing differences in SRAM transistors.
Each enrolled key generates a key code, required along with the secret to generate the specific key.
The key codes are protected by \ac{AES} encryption and stored in a private section of the eNVM.
The eNVM is a tamper-resistant nonvolatile flash memory. It has a size of 512KB, with the top 64 pages reserved for design security (keys and passcodes), inaccessible by the user.
It has a limited number of write cycles. For a predicted life span of 20 years there is a limit of 1000 writes per page of 128 bytes \cite{smartfusionDatasheet}. For a smaller life span of 10 years it has a limit of 10000 cycles per page.

The side-channel \ac{DPA} is an advanced power analysis technique to compute values from statistical analysis of multiple cryptographic operations \cite{kocher1999differential}.
Not all services in the smartfusion2 board are \ac{DPA}-resistant. ECC point multiplication, \ac{NRBG}, SRAM-PUF and KeyTree are.
On the other hand, AES, SHA-256 and HMAC accelerators have very light countermeasures, and are not considered safe to use repeatedly with the same keys or in situations where the adversary may be able to choose the cipher text.
For the non \ac{DPA}-resistant services, there is a danger of key extraction if the same key is used repeatedly.
Although to setup up this type of attack, physical access to the device is needed with an oscilloscope to measure the voltage \cite{dpaKocher2011}. Even then, the device has tamper detection mechanisms so its services can be blocked, or the device is completely reset and deleted of any sensitive information through zeroization.
% It is advisable for the services to rotate keys in a regular schedule.
% They are all safe of Timing Analysis.
% Tamper detection mechanisms are available so the user can block operations or completely reset the device with zeroization.

\subsubsection*{Secure boot}
Not validating code before its execution leads to potentially executing untrusted code. This causes problems such as hackers inserting malware to hijack systems, download intellectual property, spy on users or perform any number of attacks.
Most embedded processors do not validate code before it is executed. The SmartFusion2 \ac{SoC} solves this problem by using a non-volatile memory (eNVM) to store boot code which can be write protected. Another reason is it authenticates each stage of the boot process to create a chain-of-trust.
Other systems also implement solutions to secure boot code. Infineon secures the boot process for ARM platforms by incorporating a \ac{TPM}, compliant with version 1.2, into the processor. The \ac{TPM} operates as a root of trust to certify the platform's integrity and correct system state. This prevents tampered kernels and fault attacks.
Texas Instruments Sitara processors allows the customer to specify a public key as a root of trust to be fused into the device. This key is used to authenticate other keys that can be used to authenticate software components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{State of the Art}\label{chap:background:art}

In general, HSMs have been used for specific applications exploiting their cryptographic services, key storage and physical tampering protections.
Lesjak et al. \cite{iothardware} developed a system to secure remote snapshot acquisition, between the vendor and customers, by attaching a hardware security module to the customer product. 
The messages are protected with the authenticated-encryption scheme \ac{AES}-\ac{GCM} and a TLS connection.
The Infineon security controller stores the TLS keys, and protects the data with the authenticated-encryption scheme using its TRNG, the diffie-hellman based ECMQV algorithm for key establishment using ECC keys. This controller also contains protections against side-channel attacks such as \ac{DPA} and physical manipulation.
Seol et al. \cite{trustediaashsm} proposed a system to isolate critical operations and sensitive data from cloud administrators by implementing a \ac{HSM} next to a virtual machine.
Wolf et al. \cite{wolf2011design} implemented a HSM on a 663€ Xilinx Virtex-5 FPGA to secure network communications in vehicles. The cryptographic algorithms were implemented on the FPGA by the authors, namely AES-128 bit and ECC point-multiplication with a 256 bit curve. The board was connected to a microcontroller running linux with some additional algorithms available from a cryptographic library.
Secure coprocessors have also been used to store and manage symmetric keys for data encryption in systems which manage biomedical data \cite{canim2011biomedical}.
% ----
Existing HSMs capabilities and functionalities have been studied by some studies.
Kehret et al. \cite{tlsintegration} studied two specific boards.
VaultIC460 is a secure microcontroller manufactured by Inside Secure with a RISC CPU, it includes a varied offering of cryptographic algorithms such as: AES encryption, public-key cryptography with RSA and ECC, MAC, SHA, SSL support, as well as a random number generator. Additionally it includes several authentication mechanisms for users, to secure the connection between the application and device.
It includes 112 KB of tamper resistant secure memory for key storage and a USB connection.
ATECC508A from microsemi is a tiny security controller with asymmetric key cryptography algorithms: ECDSA and ECDH, along with SHA, a TRNG and storage of up to sixteen 256 bit keys.
These type of controllers are not suitable for this work, it is very small and limited with only a single GPIO, and no symmetric key algorithms, preventing encryption of large amounts of data. They are designed to be added to IoT devices.

The survey \cite{ivarsson2010review} studies the features of four \ac{HSM} on the market, Keyper v2 by AEP, nShield Connect 6000 by Thales, Safenet Luna and Utimaco CryptoServer.
All devices support smartcard authentication beyond the more common options of a password or PIN. The AEP and Utimaco \ac{HSM}s also have additional smartcard integration for backing up the device's internal keys.
All devices have tamper resistant storage, a \ac{TRNG}, as well as a varied range of supported cryptography services. Several AES encryption modes for both 128 and 256 bit keys, SHA, HMAC and public-key cryptography with RSA.
ECC based algorithms, ECDSA and ECDH are supported by the devices from Safenet and Utimaco.
All devices provide a PKCS\#11 interface implementation for all cryptography services. No device provides a ready-to-use application for end users. The provided API can be used to build an application adapted to their needs. The PKCS\#11 implementation does not output any unencrypted sensitive information such as keys.

Market \ac{HSM}s go from 650€ up to \$39,000 \cite{HSMpriceArticles}, \cite{HSMPresentationPrices}.
One of the smallest and cheapest devices, the YubiHSM 2 by Yubico \cite{YubiHSM2}, is a USB sized device for 650€. It supports the several SHA hashing algorithms, RSA, ECC algorithms: ECDSA and ECDH with several curves, a \ac{TRNG} and the \ac{AES}-\ac{CCM} authenticated encryption algorithm.
It provides a PKCS\#11 implementation, 128KB of tamper resistant storage for keys and a protected connection between the PKCS\#11 calls and device with authentication, integrity and confidentiality.
