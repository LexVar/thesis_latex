% #############################################################################
% This is Chapter 5
% !TEX root = ../main.tex
% #############################################################################
% Change the Name of the Chapter i the following line
\fancychapter{Implementation}
\cleardoublepage
% The following line allows to ref this chapter
\label{chap:implementation}

This chapter presents the details of the developed solution on the Hardware Security Module, the user software and the developed API to access the board's services.
It covers the implementation details, namely the standards and libraries, the developed services, their logic and how they leverage the board's existing accelerators. The communications, authentication, secure data exchange service, digital signatures, key management solution and tamper detection features are detailed.

% -----------------------------------------------------
\section{Libraries and Tools}\label{chap:implementation:tools}

The device's solution software is running on the \ac{SoC} of a SmartFusion2 board, version M2S090TS from Microsemi, with the features described in section~\ref{chap:background:computing:smartfusion}.
The application was implemented using the C programming language, with the SoftConsole v3.4 \ac{IDE} and libraries of the board functionalities, provided by Microsemi. The board's features and capabilities were configured using Libero v11.7.
The device functions as a \ac{HSM}, connected through a \ac{USB} connection to a computer. It was programmed using the external FlashPro4 programmer required to develop and debug embedded applications with SoftConsole \cite{smartfusionSecurityPractices}.
An API was implemented using the \ac{PKCS}\#11 standard for a higher device interoperability of cryptography systems. A user application which invokes the PKCS functions was implemented, and acts as user facing interface. Both this software and the API were implemented in C++, for the open source MinGW compiler in Windows 10, and is composed of a simple command line interface.
The computer running the user software and the smartfusion board, running the HSM code, are connected through a \ac{USB} connection.
The device implementation uses the available \ac{UART} communication controller and corresponding drivers for communications, while the user application uses the windows drivers to communicate with the port.
This setup allows the board to send and receive messages of 16 block bytes at a time.
% Mbedtls consideration
% It is an adequate device due to several components such as the required cryptographic functions in its system controller, a \ac{TRNG} essential for cryptography, secure storage for keys and anti-tampering protections.
% The inclusion of a cryptography library, such as Mbedtls, designed for embedded systems was considered. The library provides algorithm implementations: ECDH, ECDSA, AES encryption and HMAC. The library can be integrated with the boards functionalities and have unnecessary features disabled to lower the used memory.
% Ultimately, the security services offered by the device provide the necessary functionality to fulfill the requirements defined previously, with the exception of generating the device's certificate, but this was done by exporting the public key, generating the certificate and loading the certificate on the device.
% Beyond increasing the memory footprint, the library does not offer significant performance benefits, or security measures against side-channel attacks similar to the one's offered by the device's services.

 % \cite{parrinha2017flexible}
% The paper compares the performance of operations on the smartfusion2 with the mbedtls library and the board's security cores. It concludes AES encryption has a higher throughput of 1.8 Mbit/s on the mbedtls implementation compared to the 730 Kbit/s on the embedded core. For the elliptic curve scalar multiplication, used for ECDH, the software implementation is significantly slower, from 28.4s per operation compared to 0.57s with the embedded core.

% -----------------------------------------------------
\section{HSM Services}\label{chap:implementation:services}

The services were implemented using the security cores: SRAM-PUF, AES, HMAC, SHA, ECC, TRNG and tamper detection.
All these services are accessed through the developed PKCS\#11 API which with the communication protocol detailed in chapter \ref{chap4}.

% -----------------------------------------------------
\subsection{Login}\label{chap:implementation:services:authentication}

The login operation can always be be accessed by the user, and authenticates the user using a 8 digit PIN. All other implemented services can only be accessed after the user is logged in.
The authentication PIN is saved in the SRAM-PUF service in a predefined and static slot. When authentication is performed, the PIN is generated and read, compared with the client's supplied PIN and erased from memory.
If the user is authenticated the PIN can be changed, by enrolling and overwriting the value in the PIN assigned SRAM-PUF slot.

\subsection{Secure Communications}\label{chap:implementation:services:secure}

As previously mentioned, the security of \ac{AES}-\ac{GCM} in hardware is considered to be unsurpassed by any authenticated-encryption scheme~\cite{aesmodes}.
Unfortunately, the SmartFusion2 board, does not support this encryption algorithm, or any authenticated-encryption scheme.
Therefore the devised solution combines an \ac{AES} encryption mode with the authentication algorithm \ac{HMAC}. Among the supported \ac{AES} modes, as concluded in chapter~\ref{chap:background}, CTR mode is the most favourable option because of its efficiency and security, without the complexity of implementing a padding solution to the secure block mode \ac{CBC}.
For authentication, the board supports \ac{HMAC} with the \ac{SHA}-256 hash function, which uses a 256 bit symmetric key and generates a 256 bit code. As concluded in section \ref{chap:background:crypto:mac}, it is a well-designed construction, even though it is not the most efficient.
For combining these algorithms, studies recommend combining a secure encryption and secure \ac{MAC} with the encrypt-then-MAC method~\cite{encryptmacorder}.
The key used in HMAC should be different from the one used in encryption, to ensure the best security practices, by not reusing the same key in different algorithms. So in practice, a key used for securing communications is split in two keys, one for encryption and one for authentication.
When choosing key sizes, taking into account the limited storage capacity of the board, a smaller, but still secure, key size is preferred. The \ac{AES} 128 bit and 256 bit services guarantee 128 and 256 bit security, respectively. HMAC with SHA-256 provides 256 bit security, with 256 bit keys. According to the \ac{NIST} recommendations~\cite{nistRecommendations}, algorithms which guarantee both 128 and 256 bit security, are expected to be secure from 2031 and beyond. If storage is extremely limited, AES with 128 bit keys is a secure and more adequate option. However, 256 bit keys provide a longer life expectancy to the system with secure communications.
With AES 128 bit, the secure data service provides 128 bit security, since it has the lowest security level compared to HMAC which provides 256 bit. Choosing AES 256 bit provides 256 bit security to the service.
In the developed implementation, for every communication channel there are two 256 bit keys.
% 5. Encontrei uma solução: aproveitar as caracteristicas do modo de cifra CBC que utiliza o bloco cifrado anterior como IV do próximo, para cifrar por blocos de 36K, o máximo possível de cifrar de 1 vez.
% 6. computação de HMAC continua n é possível. Para isso foi utilizada um implementação de software com a biblioteca: https://github.com/ogay/hmac.
% 7. Isto permite cifrar uma quantidade ilimitada de dados.

For every new encryption operation a unique 16 byte \ac{IV} is generated with the \ac{NRBG} service.
The board has 64 KB of RAM. With all the code and drivers needed for this implementation, only around 36 KB of buffer space is left for data, received from the PC, to be secured. Initially two buffers, each of 18 KB, were used, one for the input data, another for the result. With small tweaks, this was improved to a single 36 KB buffer, where the initial data was stored, and the result as well, while performing the operations. Thus, the system was only able to secure 36 KB of data. The next logical step was to implement continuous cipher and authentication, by receiving chunks of data one after the other. However the board is not capable of continuous operations using its security cores.
A solution was devised by taking advantage of the AES \ac{CBC} mode's characteristics and a lightweight implementation of continuous HMAC. Its protocol is depicted in figure \ref{fig:protocol:data-exchange-chunks}. The mode starts encryption with a random IV for the first block, the IV for all the subsequent blocks is the generated ciphertext of the previous blocks. Therefore, chunks can be encrypted with this mode, using the last ciphertext block of the last chunk, as the IV for the current chunk. The user software sends the chunks one at a time, the HMAC calculation is updated for each block, and the result ciphertext is returned.
As concluded previously, CBC is a secure mode, assuming a secure padding scheme is used to prevent padding oracle attacks.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.75\textwidth]{./Images/data-exchange-chunks.png}
	\caption{Communication protocol for continuous data ciphering and authentication in the HSM with internal keys}
	\label{fig:protocol:data-exchange-chunks}
\end{figure}

% Thus \ac{AES} with 128 bit keys is preferred, since it guarantees adequate security for the foreseeable future, and is the more conservative option.
% Even though the HMAC service needs a 256 bit key, a 128 bit key can be used with the upper 128 bits padded with zeros \cite{smartfusionSecurityPractices}.
% Therefore for every communication a 256 bit key is used, the lower 128 bits for encryption and upper 128 bits for authentication.

% The encryption and authentication keys, both 128 bit, are fetched from the SRAM-PUF service, using the slot (key ID) requested by the client application.
% The returned string is either the original plaintext, or the \ac{MAC}, \ac{IV} and ciphertext, concatenated in that order.

% --------

% The system provides a single hash algorithm, \ac{SHA}-256, which has a security strength of 128 bits.
% The \ac{HMAC}-\ac{SHA}-256 algorithm needs a 256 bit key, different from the one used with encryption, to ensure the best security practices. A 128 bit key can be used, if padded with zeros. Thus, for every communication, a 128 bit key for encryption and a 128 bit key for authentication is used. In total, a 256 bit shared secret.

% The qualified digital signatures operation combines \ac{ECC} and the \ac{SHA}-256 hash algorithm, and provides 128 bit security, calculated by taking the smallest security strength value of both algorithms. For the encryption and authentication operation combining \ac{AES}-128 and \ac{HMAC}-\ac{SHA}-256, 128 bit security is provided.

% -----------------
\subsection{Digital Signatures}\label{chap:implementation:services:signatures}

The board supports keys on the \ac{ECC} P-384 curve. The board has three \ac{ECC} core functions, one for multiplication of a point with a scalar value. This operation allows generating a public key, a point, from the multiplication of the private key, a 48 byte scalar value, and the curve's base point. The base point can be obtained with another board function.
The last function is the addition of two points on the curve.
The board is not equipped with a \ac{ECDSA} API. The algorithm can be implemented combining the provided ECC security cores, and a big numbers library which allows operations between numbers of at least 48 bytes.
A big number library was included in the implementation for the purpose of implementing ECC signatures. The implementation was successfully tested, however with some drawbacks.
The library was striped of every unnecessary function and code, still taking 54 KB of RAM space. Thus, this functionality only works if all other implemented features are disabled, with data of up to 1.5 KB.
This is an extremely limited use case, and less than ideal. Future work should revise this functionality by evaluating existing lightweight libraries which provide the necessary features, or even a custom implementation.

% -----------------
\subsection{Key Management}\label{chap:implementation:services:key-import}

% -----------------
\subsection{Key Generation}\label{chap:implementation:services:key-generation}

The supported \ac{ECC} P-384 curve guarantees 192 bit security.
The implemented new key generation operation protocol is defined in ~\ref{eq:ecdh-kdf}.
The peer's public key is supplied by the client application, and the device's private key is fetched from a predetermined PUF slot where it is saved.

For the ECDH algorithm the ECC scalar multiplication board accelerator is used. It multiplies a scalar value of 48 bytes, the private key, with a point with a x and y coordinate of both 48 bytes (96 bytes total), the public key.
The result is a 96 byte point, which is effectively the shared secret.
Then to generate the 256 bit key, the KeyTree service is applied as a key derivation function on the shared secret combined with a salt, which can be public.
The generated key is enrolled in the first available PUF slot, which is provided by a function in the API, and is returned to the user as the newly generated key ID.

% -----------------
\subsection{Tamper Detection}\label{chap:implementation:services:tamper-detection}

Tamper and failure events detection is implemented. When certain events occur, flags are set which prevent the user from performing operations, to protect all possible sensitive data.
On tamper detection events, zeroization is performed on the device, erasing all keys and data from the device. This process either makes the board unusable or reset to the default fabric state.
These measures effectively have a denial-of-service effect but is a trade-off in order to avoid successful attacks and potential leaks of sensitive information, e.g. \ac{DPA}.

Using the AES and HMAC services, in the secure communications operation, which are not fully DPA-resistant, makes the keys and information vulnerable to these attacks, as discussed in section \ref{chap:background:computing:smartfusion}.
Attackers need physical access to the board and voltage measurement tools to perform them.
With the developed implementation using tamper detection, which blocks attackers from using the device and zeroization which erases all sensitive data from the device, helps mitigate this type of attacks.
All this is invalid, if the attacks somehow gain access to the user's authentication PIN.
Which is why regular replacement of symmetric keys used in the vulnerable operations is recommended, and is a missing feature of the implementation.
For future work a feature could be developed where a central entity, once every month, sends a encrypted message using pre-distributed keys, with a new key set, to replace the existing set.
% As discussed in section \ref{chap:background:computing:smartfusion}, physical access to the board is needed to perform these attacks

% TODO: maybe for conclusion: the secure communications service provides 128 bit security, and the ECDH algorithm provides 192 bit security.

% -----------------------------------------------------
\section{PKCS\#11 Interface}\label{chap:implementation:app:interface}

The application only supports one token and one session for the token.
PKCS\#11 defines two types of users, the regular user and security office. The implemented application does not make that distinction. Both types of user can login and perform operations.
The implemented PKCS\#11 API is listed in table \ref{tab:pkcs11-api}.

The implemented application initializes the cryptoki application and opens the session with the device through the \texttt{C\_Initialize} and \texttt{C\_OpenSession} functions.
The opposite \texttt{C\_CloseSession} and \texttt{C\_Finalize} functions close the session and terminate the cryptoki application.
The interface handles the input from the user and uses the data to call the functions in the implemented PKCS\#11 API.
First the user inputs the operation code he wishes to perform, and the application handles the correct API calls to the PKCS\#11 interface.
The authentication operation calls the \texttt{C\_Login} function. The authentication PIN can then be changed with the \texttt{C\_SetPIN} function.
The \texttt{C\_Logout} function logs out the user. Only the operation code is needed for this operation.

To encrypt and authenticate some data, a local object for the secret key is created with \texttt{C\_CreateObject}. It does not contain the key data, only the key ID, so it can be passed of to the PKCS\#11 API. The encryption is performed through calls to \texttt{C\_EncryptInit} and then \texttt{C\_Encrypt}.
The same logic applied to decryption with \texttt{C\_DecryptInit} and then \texttt{C\_Decrypt}

For deleting a key on the device, first a secret key object is created with its ID, like before, and then a call to \texttt{C\_DestroyObject} handle the rest.
A new key is generated with the ECDH mechanism and \ac{SHA}-256 key derivation function, with a call to \texttt{C\_DeriveKey}.

Only one custom which is called directly is implemented. The \texttt{HSM\_C\_GetKeyList} returns the number of enrolled keys in the device.
% The solution should support a plethora of devices, as it will increase the adoptability of the solution among clients. This entails the use of a widely established protocol, which clearly defines a set of functions and standards the system should follow.
% The \ac{PKCS} \#11 standard will be utilized to fulfill this requirements. It allows operations to be standardized across different devices, increasing the range of supported devices. By implementing the system in accordance with these guidelines, it will have a higher device interoperability. Additionally, it allows the application to use, create and modify objects, without exposing them to its memory.

% -----------------------------------------------------
% -----------------------------------------------------
\section{Summary}\label{chap:implementation:summary}

% % -----------------------------------------------------
% \subsection{Key Management Protocols}\label{chap:implementation:protocol:key}
%
% The protocols for the communication management operations are detailed next, namely for symmetric key generation. The protocol to generate a new symmetric key with another entity using asymmetric cryptography is detailed in figure~\ref{fig:protocol:ecdh}.
%
% \begin{figure}[h!]
%         \centering
%         \includegraphics[width=0.60\textwidth]{./Images/ecdh.png}
%         \caption{Communication protocol to generate symmetric keys, with the HSM internal private key, and stored them internally}
%         \label{fig:protocol:ecdh}
% \end{figure}
%
% % The device calls the ECDH algorithm with its private key and the received public key to generate a secret and run it through a key derivation function with the salt value to obtain the new symmetric key. The service's formula is thus:
% The user forwards the operation code, public key and salt value to the device.
% The device will then generate a symmetric key, using the process in equation \ref{eq:ecdh-kdf}.
%
% \begin{equation}
%         \label{eq:ecdh-kdf}
%         KDF\{ECDH_{K}\{K^{-1}\}, Salt\}
% \end{equation}
%
% A secret is generated from the \ac{ECDH} algorithm, with the device's private key, and another entity's public key. The same secret can be generated with the device's public key and the other entity's private key.
% This secret is run through a key derivation function in conjunction with a salt which can be public, to generate a symmetric key. If both entities generate the same secret and agree on the same salt value, the generated key is identical.
%
% The new key is then stored in non-volatile memory encrypted with the dedicated symmetric encryption key for storage, saved in its PUF slot.
% A new unique ID is generated for the key, which is stored alongside the key in memory. This ID is returned to the user along with the operation success status.
%
% % -----------------------------------------------------
% \subsection{Import Keys into HSM Protocol}\label{chap:implementation:protocol:import-keys}
%
% This section details the protocol to import a list of encrypted symmetric keys, into the device.
% The imported keys must be encrypted with a predefined symmetric key, stored in a dedicated PUF slot inside the device. This service is useful so a central management section with a similar device can distribute keys to the enrolled entities, on a regular schedule, such as monthly.
% The protocol for this service is pictured in figure \ref{fig:protocol:import-keys}.
%
% \begin{figure}[h!]
%         \centering
%         \includegraphics[width=0.60\textwidth]{./Images/import-keys.png}
%         \caption{Communication protocol to import encrypted symmetric keys, and store them encrypted in the HSM's memory}
%         \label{fig:protocol:import-keys}
% \end{figure}
%
% The only transmission consists in the client sending the operation code, keys length and key data.
% Then, the device decrypts and authenticates the keys using a predefined symmetric key stored in a secure PUF slot. The protocol used is the same for secure data exchange described in the previous section.
%
% Each key consists of 1 byte for its ID, 1 byte for its size and remaining bytes for the key data.
% The decrypted list of keys is encrypted again, using \ac{AES} \ac{CTR} mode with another predefined symmetric key for storage of data in non-volatile memory. The ciphertext, randomly generated IV and ciphertext length is stored in memory. To provide authentication and thus protection against tampering, a \ac{MAC} is generated from the three pieces of data and stored in a PUF slot.
%
% In order to fetch a stored symmetric key to use in one of the implemented services, the \ac{MAC} is generated and compared to the PUF slot. If identical, the key can be decrypted from memory using the same key used for its encryption and identified with its ID.

% All data is either stored in the secure eNVM portion, or in the non-volatile memory, encrypted with an internal \ac{KEK}.
